# 强制类型转换

## 值类型转换
>将值从一种类型转换为另一种类型通常称为类型转换（ type casting），这是显式的情况；隐
式的情况称为强制类型转换（ coercion）。

JavaScript 中的强制类型转换总是返回标量基本类型值，如字符串、数字和布尔值，不会返回对象和函数。

```
var num = 1
String(num)  // '1'
typeof String(num)  // 'string'
```

隐式类型转换与显式类型转换

```
var a = 42
var b = a + ''  // 隐式类型转换
var b = String(a)  // 显式类型转换
```

这里的“显式”和“隐式”以及“明显的副作用”和“隐藏的副作用”，都是相对而言的。要是你明白 a + "" 是怎么回事，它对你来说就是“显式”的。相反，如果你不知道 String(..) 可以用来做字符串强制类型转换，它对你来说可能就是“隐式”的。

### 抽象值操作

#### toString
>非字符串转换为字符串

```
var a = 42
a.toString()  // '42'

var a = [1, 2, 3]
a.toString()  // '1,2,3'
```

#### JSON 序列化
>所有安全的 JSON 值（ JSON-safe）都可以使用 JSON.stringify(..) 字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。

```
JSON.stringify(42)  // "42"
JSON.stringify("42")  // ""42""
JSON.stringify(null)  // "null"
JSON.stringify(true)  // "true"
JSON.stringify(undefined)  // undefined
JSON.stringify(function() {})  // undefined
```

undefined、 function、 symbol（ ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON结构标准，支持 JSON 的语言无法处理它们。
JSON.stringify(..) 在对象中遇到 undefined、 function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。
如果对象中定义了 toJSON() 方法， JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。
toJSON() 方法存在于日期对象中

我们可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用
来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像。

如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。

```
var obj = {
  a: 1,
  b: 2,
  c: 3,
}
JSON.stringify(obj, ['a', 'b'])  // "{"a":"1","b":"2"}"
```

JSON.string 还有一个可选参数 space，用来指定输出的缩进格式。
JSON.stringify(value, ?replacer, ?space)

JSON.stringify(..) 并不是强制类型转换。

与 toString() 的渊源

* 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。
* 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。






